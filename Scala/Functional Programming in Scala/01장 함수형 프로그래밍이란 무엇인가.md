함수형 프로그래밍(FP)은 **순수 함수(pure function)** 들로만, 다시 말해서 부수 효과(side effect)가 없는 함수들로만 구축한다는 전체에 기초한다.

부수효과 : 그냥 결과를 돌려주는 것 이외의 어떤 일

* 변수를 수정한다
* 자료구조를 제자리에서 수정한다
* 객체의 필드를 설정한다.
* 예외를 던지거나 오류를 내면서 실행을 중단한다.
* 콘솔에 출력하거나 사용자의 입력을 읽어들인다.
* 파일에 기록하거나 파일에서 읽어들인다.
* 화면에 그린다.

> 응?? 숨수 함수만으로 뭘 어떻게 개발하라는 거지?

함수형 프로그래밍은 프로그램을 장성하는 방식에 대한 제약이지, 표현 가능한 프로그램의 종류에 대한 제약이 아니라는 것이다. 모든 종류의 프로그램을 부수 효과 없이 표현하는 방법을 배우게 된다. FP의 원리를 따르면 모듈성이 증가하여 이롭다.

### 부수 효과가 있는 프로그램

```Scala
class Cafe {
  def buyCoffe(cc: CreditCard): Coffee = {
    val cup = new Coffee()
    cc.charge(cup.price)
    cup
  }
}
```

`cc.charge(cup.price)`가 부수효과의 예이다.

#### 지급 객체 추가

```Scala
class Cafe {
  def buyCoffe(cc: CreditCard, p: Payments): Coffee = {
    val cup = new Coffee()
    p.charge(cc, cup.price)
    cup
  }
}
```

### 합수적 해법: 부수 효과의 제거

부수 효과를 제거하고 buyCoffee가 Coffee뿐만 아니라 청구건을 하나의 값으로 돌려주게 하는 것이다.

```Scala
class Cafe {
  def buyCoffe(cc: CreditCard): (Coffee, Charge) = {
    val cup = new Coffee()    
    (cup, Charge(cc, cup.price))
  }
}
```

청구건의 생성 문제가 청구건의 처리 또는 연동 문제와 분리되었다.

## (순수)함수란 구체적으로 무엇인가?

입력 형식이 A이고 출력 형식이 B인 함수 f가 있다. 모든 a: A를 각각 하나의 값 b: B에 연관시키되, **b가 오직 a의 값에 의해서만 결정된다** 는 조건을 만족하는 계산이다. 내부 또는 외부 공정의 상태 변경은 f(a)의 결과를 계산하는 데 어떠한 영향도 주지 않는다.

주어진 입력으로 뭔가를 계산하는 것 외에는 어떤 관찰 가능한 영향도 미치지 않는다. 이를 순수 함수라고 부른다.

순수 함수의 이러한 개념을 **참조 투명성(referential transparency, RT)** 이라는 개념으로 공식화한다. 참조 투명성은 함수가 아니라 표현식(expression)의 한 속성이다. 즉, 스칼라 해석기(interpreter)에 입력했을 때 답이 나오는 모든 것이 표현식이다. 예를 들어 2 + 3. 부수 효과가 없다. 이 표현식의 평가(evaluation)는 항상 5라는 값는 결과를 낸다.

> 참조 투명성과 순수성
만일 모든 프로그램 p에 대해 표현식 e의 모든 출현(occurrence)을 e의 평가 결과로 치환해도 p의 의미에 아무 영향이 미치지 않는다면, 그 표현식 e는 참조에 투명하다(referentially transparent). 만일 표현식 f(x)가 참조에 투명한 모든 x에 대해 참조에 투명하면, 함수 f는 순수하다(pure). https://github.com/fpinscala/fpinscala
